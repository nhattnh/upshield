<?php
/**
 * Malware Scanner
 *
 * Scans theme and plugin files for malicious code patterns.
 *
 * @package UpShield_WAF
 */

namespace UpShield\Scanner;

if (!defined('ABSPATH')) {
    exit;
}

class MalwareScanner {
    const STATUS_RUNNING = 'running';
    const STATUS_COMPLETED = 'completed';
    const STATUS_FAILED = 'failed';

    /**
     * Loaded signatures
     */
    private $signatures = [];

    /**
     * Whitelist patterns
     */
    private $whitelist_patterns = [];

    /**
     * Scan extensions
     */
    private $scan_extensions = [];

    /**
     * Constructor - load signatures
     */
    public function __construct() {
        $this->load_signatures();
    }

    /**
     * Load malware signatures from JSON file.
     */
    private function load_signatures() {
        $file = UPSHIELD_PLUGIN_DIR . 'rules/malware-signatures.json';
        if (!file_exists($file)) {
            return;
        }

        $data = json_decode(file_get_contents($file), true);
        if (!is_array($data)) {
            return;
        }

        $this->signatures = $data['signatures'] ?? [];
        $this->whitelist_patterns = $data['whitelist_patterns'] ?? [];
        $this->scan_extensions = $data['scan_extensions'] ?? ['php'];
    }

    /**
     * Run a malware scan on themes and plugins.
     */
    public function run_scan($scope = 'all') {
        global $wpdb;

        $table_scans = $wpdb->prefix . 'upshield_malware_scans';
        $table_items = $wpdb->prefix . 'upshield_malware_scan_items';

        $started_at = current_time('mysql', true);

        // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- WAF performance
        $wpdb->insert($table_scans, [
            'started_at' => $started_at,
            'status' => self::STATUS_RUNNING,
            'scope' => $scope,
        ]);

        $scan_id = (int) $wpdb->insert_id;

        $summary = [
            'scan_id' => $scan_id,
            'status' => self::STATUS_RUNNING,
            'scope' => $scope,
            'total_files' => 0,
            'clean_files' => 0,
            'infected_files' => 0,
            'suspicious_files' => 0,
            'started_at' => $started_at,
            'finished_at' => null,
        ];

        $directories = $this->get_scan_directories($scope);

        foreach ($directories as $dir_info) {
            $this->scan_directory($dir_info, $scan_id, $table_items, $summary);
        }

        $finished_at = current_time('mysql', true);
        // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- WAF performance
        $wpdb->update($table_scans, [
            'finished_at' => $finished_at,
            'status' => self::STATUS_COMPLETED,
            'total_files' => $summary['total_files'],
            'clean_files' => $summary['clean_files'],
            'infected_files' => $summary['infected_files'],
            'suspicious_files' => $summary['suspicious_files'],
        ], ['id' => $scan_id]);

        $summary['status'] = self::STATUS_COMPLETED;
        $summary['finished_at'] = $finished_at;

        return $summary;
    }

    /**
     * Get directories to scan based on scope.
     */
    private function get_scan_directories($scope) {
        $dirs = [];

        if ($scope === 'all' || $scope === 'themes') {
            $themes_dir = get_theme_root();
            if (is_dir($themes_dir)) {
                $dirs[] = [
                    'path' => $themes_dir,
                    'type' => 'theme',
                    'base' => $themes_dir,
                ];
            }
        }

        if ($scope === 'all' || $scope === 'plugins') {
            $plugins_dir = WP_PLUGIN_DIR;
            if (is_dir($plugins_dir)) {
                $dirs[] = [
                    'path' => $plugins_dir,
                    'type' => 'plugin',
                    'base' => $plugins_dir,
                ];
            }
        }

        if ($scope === 'all' || $scope === 'mu-plugins') {
            $mu_plugins_dir = WPMU_PLUGIN_DIR;
            if (is_dir($mu_plugins_dir)) {
                $dirs[] = [
                    'path' => $mu_plugins_dir,
                    'type' => 'mu-plugin',
                    'base' => $mu_plugins_dir,
                ];
            }
        }

        if ($scope === 'all' || $scope === 'uploads') {
            $uploads_dir = wp_upload_dir();
            if (!empty($uploads_dir['basedir']) && is_dir($uploads_dir['basedir'])) {
                $dirs[] = [
                    'path' => $uploads_dir['basedir'],
                    'type' => 'upload',
                    'base' => $uploads_dir['basedir'],
                ];
            }
        }

        return $dirs;
    }

    /**
     * Scan a directory recursively.
     */
    private function scan_directory($dir_info, $scan_id, $table_items, &$summary) {
        $path = $dir_info['path'];
        $type = $dir_info['type'];
        $base = $dir_info['base'];

        if (!is_dir($path) || !is_readable($path)) {
            return;
        }

        try {
            $iterator = new \RecursiveIteratorIterator(
                new \RecursiveDirectoryIterator($path, \FilesystemIterator::SKIP_DOTS),
                \RecursiveIteratorIterator::SELF_FIRST
            );

            foreach ($iterator as $file) {
                if (!$file->isFile() || !$file->isReadable()) {
                    continue;
                }

                $filepath = $file->getPathname();
                $extension = strtolower($file->getExtension());

                // Only scan PHP-like files
                if (!in_array($extension, $this->scan_extensions, true)) {
                    continue;
                }

                // Skip whitelisted paths
                if ($this->is_whitelisted($filepath)) {
                    continue;
                }

                // Skip very large files (>2MB)
                if ($file->getSize() > 2 * 1024 * 1024) {
                    continue;
                }

                $summary['total_files']++;
                $findings = $this->scan_file($filepath);

                if (empty($findings)) {
                    $summary['clean_files']++;
                    continue;
                }

                // Determine severity
                $max_severity = $this->get_max_severity($findings);

                if (in_array($max_severity, ['critical', 'high'])) {
                    $summary['infected_files']++;
                } else {
                    $summary['suspicious_files']++;
                }

                // Store findings
                $relative_path = ltrim(str_replace($base, '', $filepath), '/\\');
                $this->insert_finding($table_items, $scan_id, [
                    'file_path' => $relative_path,
                    'file_type' => $type,
                    'severity' => $max_severity,
                    'findings' => $findings,
                    'file_size' => $file->getSize(),
                    'file_mtime' => gmdate('Y-m-d H:i:s', $file->getMTime()),
                ]);
            }
        } catch (\Exception $e) {
            // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log -- WAF debug logging
            error_log('UpShield Malware Scanner error: ' . $e->getMessage());
        }
    }

    /**
     * Scan a single file for malware patterns.
     */
    private function scan_file($filepath) {
        $findings = [];

        $content = @file_get_contents($filepath);
        if ($content === false) {
            return $findings;
        }

        // Scan with each signature category
        $lines = explode("\n", $content);
        foreach ($this->signatures as $category => $rules) {
            foreach ($rules as $rule) {
                $pattern = '/' . $rule['pattern'] . '/i';

                // Suppress warnings for invalid patterns
                if (@preg_match($pattern, $content, $matches)) {
                    $matched_text = isset($matches[0]) ? substr($matches[0], 0, 100) : '';
                    
                    // Try to find line number and extract code snippet
                    $code_snippet = '';
                    foreach ($lines as $line_num => $line) {
                        if (preg_match($pattern, $line)) {
                            // Extract 5 lines around the match (2 before + current + 2 after)
                            $start_line = max(0, $line_num - 2);
                            $end_line = min(count($lines) - 1, $line_num + 2);
                            $snippet_lines = array_slice($lines, $start_line, $end_line - $start_line + 1);
                            
                            // Format with line numbers
                            $target_line_idx = $line_num - $start_line;
                            foreach ($snippet_lines as $idx => $snippet_line) {
                                $actual_line = $start_line + $idx + 1;
                                $line_content = rtrim($snippet_line);
                                // Mark the line containing the match
                                if ($idx === $target_line_idx) {
                                    $line_content = '>>> ' . $line_content;
                                }
                                $code_snippet .= sprintf("%4d | %s\n", $actual_line, $line_content);
                            }
                            break; // Only take first match
                        }
                    }
                    
                    $finding = [
                        'rule_id' => $rule['id'],
                        'category' => $category,
                        'name' => $rule['name'],
                        'severity' => $rule['severity'],
                        'description' => $rule['description'],
                        'matched' => $matched_text,
                    ];
                    
                    // Add code snippet if available
                    if (!empty($code_snippet)) {
                        $finding['code_snippet'] = trim($code_snippet);
                    }
                    
                    $findings[] = $finding;
                }
            }
        }

        // Additional heuristic checks
        $heuristic_findings = $this->heuristic_analysis($content, $filepath);
        $findings = array_merge($findings, $heuristic_findings);

        return $findings;
    }

    /**
     * Perform heuristic analysis on file content.
     */
    private function heuristic_analysis($content, $filepath) {
        $findings = [];
        $lines = explode("\n", $content);

        // Check for high entropy (heavily obfuscated code)
        $entropy = $this->calculate_entropy($content);
        if ($entropy > 5.5 && strlen($content) > 1000) {
            // Extract a sample of code to show obfuscation (middle section, ~10 lines)
            $total_lines = count($lines);
            $sample_start = max(0, intval($total_lines * 0.3)); // Start at 30% of file
            $sample_end = min($total_lines - 1, $sample_start + 10);
            $sample_lines = array_slice($lines, $sample_start, $sample_end - $sample_start + 1);
            
            $code_snippet = '';
            foreach ($sample_lines as $idx => $line) {
                $actual_line = $sample_start + $idx + 1;
                $code_snippet .= sprintf("%4d | %s\n", $actual_line, rtrim($line));
            }
            
            $findings[] = [
                'rule_id' => 'HEURISTIC_001',
                'category' => 'heuristic',
                'name' => 'High Entropy Content',
                'severity' => 'medium',
                'description' => sprintf('File has unusually high entropy (%.2f) indicating possible obfuscation', $entropy),
                'matched' => 'Entropy: ' . round($entropy, 2),
                'code_snippet' => trim($code_snippet),
            ];
        }

        // Check for multiple dangerous functions in same file
        $dangerous_functions = [
            'eval' => 'Code execution',
            'base64_decode' => 'Encoding/Obfuscation',
            'gzinflate' => 'Compression (often used to hide code)',
            'gzuncompress' => 'Compression (often used to hide code)',
            'str_rot13' => 'Encoding/Obfuscation',
            'shell_exec' => 'Shell command execution',
            'system' => 'System command execution',
            'passthru' => 'Command execution with output',
            'exec' => 'Command execution',
            'assert' => 'Code execution',
            'create_function' => 'Dynamic function creation',
            'preg_replace' => 'Can execute code with /e modifier'
        ];

        $found_functions = [];
        $lines = explode("\n", $content);
        
        foreach ($dangerous_functions as $func => $desc) {
            // Use word boundary to avoid false positives (e.g., "system" in "filesystem")
            $pattern = '/\b' . preg_quote($func, '/') . '\s*\(/i';
            
            foreach ($lines as $line_num => $line) {
                if (preg_match($pattern, $line, $matches, PREG_OFFSET_CAPTURE)) {
                    // Extract code snippet: 2 lines before + current line + 2 lines after
                    $start_line = max(0, $line_num - 2);
                    $end_line = min(count($lines) - 1, $line_num + 2);
                    $snippet_lines = array_slice($lines, $start_line, $end_line - $start_line + 1);
                    
                    // Format snippet with line numbers
                    $snippet = '';
                    $target_line_idx = $line_num - $start_line;
                    foreach ($snippet_lines as $idx => $snippet_line) {
                        $actual_line = $start_line + $idx + 1;
                        $line_content = rtrim($snippet_line);
                        // Mark the line containing the function
                        if ($idx === $target_line_idx) {
                            $line_content = '>>> ' . $line_content;
                        }
                        $snippet .= sprintf("%4d | %s\n", $actual_line, $line_content);
                    }
                    
                    $found_functions[$func] = [
                        'desc' => $desc,
                        'snippet' => trim($snippet),
                        'line' => $line_num + 1
                    ];
                    break; // Only take first occurrence of each function
                }
            }
        }

        if (count($found_functions) >= 4) {
            $func_list = [];
            $code_snippets = [];
            foreach ($found_functions as $func => $info) {
                $func_list[] = sprintf(
                    "%s() - %s (Line %d)",
                    $func,
                    $info['desc'],
                    $info['line']
                );
                $code_snippets[] = sprintf(
                    "%s() - %s (Line %d)\n%s",
                    $func,
                    $info['desc'],
                    $info['line'],
                    $info['snippet']
                );
            }
            $findings[] = [
                'rule_id' => 'HEURISTIC_002',
                'category' => 'heuristic',
                'name' => 'Multiple Dangerous Functions',
                'severity' => 'high',
                'description' => sprintf('File contains %d potentially dangerous functions that could be used for malicious purposes', count($found_functions)),
                'matched' => implode("\n", $func_list),
                'code_snippet' => implode("\n\n", $code_snippets),
            ];
        }

        // Check for hidden PHP in non-PHP extensions
        $extension = strtolower(pathinfo($filepath, PATHINFO_EXTENSION));
        if (!in_array($extension, ['php', 'phtml', 'inc']) && preg_match('/<\?php/i', $content)) {
            // Find line with PHP tag
            $php_line_num = 0;
            foreach ($lines as $line_num => $line) {
                if (preg_match('/<\?php/i', $line)) {
                    $php_line_num = $line_num;
                    break;
                }
            }
            
            // Extract snippet around PHP tag
            $start_line = max(0, $php_line_num - 2);
            $end_line = min(count($lines) - 1, $php_line_num + 5);
            $snippet_lines = array_slice($lines, $start_line, $end_line - $start_line + 1);
            
            $code_snippet = '';
            $target_line_idx = $php_line_num - $start_line;
            foreach ($snippet_lines as $idx => $snippet_line) {
                $actual_line = $start_line + $idx + 1;
                $line_content = rtrim($snippet_line);
                if ($idx === $target_line_idx) {
                    $line_content = '>>> ' . $line_content;
                }
                $code_snippet .= sprintf("%4d | %s\n", $actual_line, $line_content);
            }
            
            $findings[] = [
                'rule_id' => 'HEURISTIC_003',
                'category' => 'heuristic',
                'name' => 'PHP Code in Non-PHP File',
                'severity' => 'high',
                'description' => 'PHP code found in file with non-PHP extension',
                'matched' => 'Extension: ' . $extension,
                'code_snippet' => trim($code_snippet),
            ];
        }

        // Check for very long single lines (common in obfuscated malware)
        foreach ($lines as $line_num => $line) {
            if (strlen($line) > 5000 && preg_match('/[a-zA-Z0-9+\/=]{1000,}/', $line)) {
                // Extract snippet: 2 lines before + long line (truncated) + 2 lines after
                $start_line = max(0, $line_num - 2);
                $end_line = min(count($lines) - 1, $line_num + 2);
                $snippet_lines = array_slice($lines, $start_line, $end_line - $start_line + 1);
                
                $code_snippet = '';
                $target_line_idx = $line_num - $start_line;
                foreach ($snippet_lines as $idx => $snippet_line) {
                    $actual_line = $start_line + $idx + 1;
                    $line_content = rtrim($snippet_line);
                    
                    // Truncate very long line for display
                    if ($idx === $target_line_idx && strlen($line_content) > 200) {
                        $line_content = substr($line_content, 0, 150) . '... [TRUNCATED - ' . strlen($snippet_line) . ' chars total] ...' . substr($line_content, -50);
                        $line_content = '>>> ' . $line_content;
                    } elseif ($idx === $target_line_idx) {
                        $line_content = '>>> ' . $line_content;
                    }
                    
                    $code_snippet .= sprintf("%4d | %s\n", $actual_line, $line_content);
                }
                
                $findings[] = [
                    'rule_id' => 'HEURISTIC_004',
                    'category' => 'heuristic',
                    'name' => 'Very Long Encoded Line',
                    'severity' => 'medium',
                    'description' => 'Extremely long line with encoded content detected',
                    'matched' => 'Line length: ' . strlen($line) . ' characters',
                    'code_snippet' => trim($code_snippet),
                ];
                break;
            }
        }

        // Check for suspicious file timestamps (far future or very old)
        $mtime = filemtime($filepath);
        $now = time();
        if ($mtime > $now + 86400 || $mtime < strtotime('2005-01-01')) {
            // Show first 10 lines of file as context
            $code_snippet = '';
            $sample_lines = array_slice($lines, 0, min(10, count($lines)));
            foreach ($sample_lines as $idx => $line) {
                $code_snippet .= sprintf("%4d | %s\n", $idx + 1, rtrim($line));
            }
            
            $findings[] = [
                'rule_id' => 'HEURISTIC_005',
                'category' => 'heuristic',
                'name' => 'Suspicious File Timestamp',
                'severity' => 'low',
                'description' => 'File has unusual modification timestamp',
                'matched' => 'Timestamp: ' . gmdate('Y-m-d H:i:s', $mtime) . ' (Current: ' . gmdate('Y-m-d H:i:s', $now) . ')',
                'code_snippet' => trim($code_snippet),
            ];
        }

        return $findings;
    }

    /**
     * Calculate Shannon entropy of content.
     */
    private function calculate_entropy($content) {
        $chars = count_chars($content, 1);
        $len = strlen($content);

        if ($len === 0) {
            return 0;
        }

        $entropy = 0;
        foreach ($chars as $count) {
            $freq = $count / $len;
            $entropy -= $freq * log($freq, 2);
        }

        return $entropy;
    }

    /**
     * Check if file path is whitelisted.
     */
    private function is_whitelisted($filepath) {
        foreach ($this->whitelist_patterns as $pattern) {
            if (stripos($filepath, $pattern) !== false) {
                return true;
            }
        }

        // Skip UpShield's own files
        if (stripos($filepath, 'upshield-waf') !== false) {
            return true;
        }

        return false;
    }

    /**
     * Get maximum severity from findings.
     */
    private function get_max_severity($findings) {
        $severity_order = ['critical' => 4, 'high' => 3, 'medium' => 2, 'low' => 1];
        $max_level = 0;
        $max_severity = 'low';

        foreach ($findings as $finding) {
            $level = $severity_order[$finding['severity']] ?? 0;
            if ($level > $max_level) {
                $max_level = $level;
                $max_severity = $finding['severity'];
            }
        }

        return $max_severity;
    }

    /**
     * Insert a finding into the database.
     */
    private function insert_finding($table, $scan_id, $data) {
        global $wpdb;

        // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- WAF performance
        $wpdb->insert($table, [
            'scan_id' => $scan_id,
            'file_path' => $data['file_path'],
            'file_type' => $data['file_type'],
            'severity' => $data['severity'],
            'findings' => json_encode($data['findings']),
            'file_size' => $data['file_size'],
            'file_mtime' => $data['file_mtime'],
        ]);
    }

    /**
     * Reschedule malware scan cron based on options.
     */
    public static function reschedule($options) {
        $hook = 'upshield_malware_scan_event';
        wp_clear_scheduled_hook($hook);

        $enabled = !empty($options['malware_scanner_enabled']);
        $schedule = $options['malware_scan_schedule'] ?? 'manual';

        if (!$enabled || $schedule === 'manual') {
            return;
        }

        $recurrence = $schedule === 'weekly' ? 'weekly' : 'daily';
        wp_schedule_event(time(), $recurrence, $hook);
    }

    /**
     * Get latest scan summary.
     */
    public function get_latest_scan() {
        global $wpdb;
        $table_scans = $wpdb->prefix . 'upshield_malware_scans';
        if (!$this->table_exists($table_scans)) {
            return null;
        }
        return $wpdb->get_row("SELECT * FROM {$table_scans} ORDER BY id DESC LIMIT 1", ARRAY_A);
    }

    /**
     * Get scan summary and items.
     */
    public function get_scan($scan_id, $args = []) {
        global $wpdb;

        $table_scans = $wpdb->prefix . 'upshield_malware_scans';
        $table_items = $wpdb->prefix . 'upshield_malware_scan_items';
        if (!$this->table_exists($table_scans) || !$this->table_exists($table_items)) {
            return null;
        }

        $scan = $wpdb->get_row($wpdb->prepare("SELECT * FROM {$table_scans} WHERE id = %d", $scan_id), ARRAY_A);
        if (!$scan) {
            return null;
        }

        $page = max(1, absint($args['page'] ?? 1));
        $per_page = max(1, min(200, absint($args['per_page'] ?? 50)));
        $offset = ($page - 1) * $per_page;
        $severity = sanitize_text_field($args['severity'] ?? '');

        $where = "WHERE scan_id = %d";
        $params = [$scan_id];
        if (!empty($severity)) {
            $where .= " AND severity = %s";
            $params[] = $severity;
        }

        $total_items = $wpdb->get_var($wpdb->prepare(
            "SELECT COUNT(*) FROM {$table_items} {$where}",
            $params
        ));

        $params[] = $per_page;
        $params[] = $offset;

        $items = $wpdb->get_results($wpdb->prepare(
            "SELECT * FROM {$table_items} {$where} ORDER BY 
                CASE severity 
                    WHEN 'critical' THEN 1 
                    WHEN 'high' THEN 2 
                    WHEN 'medium' THEN 3 
                    WHEN 'low' THEN 4 
                END ASC, 
                id DESC 
            LIMIT %d OFFSET %d",
            $params
        ), ARRAY_A);

        // Parse findings JSON
        foreach ($items as &$item) {
            $item['findings'] = json_decode($item['findings'], true) ?: [];
        }

        return [
            'scan' => $scan,
            'items' => $items,
            'total_items' => (int) $total_items,
            'page' => $page,
            'per_page' => $per_page,
        ];
    }

    /**
     * Check if a table exists.
     */
    private function table_exists($table_name) {
        global $wpdb;
        $like = $wpdb->esc_like($table_name);
        $result = $wpdb->get_var($wpdb->prepare("SHOW TABLES LIKE %s", $like));
        return !empty($result);
    }
}
