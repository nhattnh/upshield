<?php
/**
 * UpShield Early Blocker
 * 
 * This file is loaded BEFORE WordPress to block malicious IPs immediately.
 * This provides maximum performance by blocking at the earliest possible stage.
 * 
 * DO NOT EDIT THIS FILE MANUALLY - It is auto-generated by UpShield WAF.
 */

// This file is loaded BEFORE WordPress via auto_prepend_file

// 0. Skip WordPress admin requests IMMEDIATELY
// Admin requests should never be blocked by early blocker
$request_uri = $_SERVER['REQUEST_URI'] ?? '';
$script_name = $_SERVER['SCRIPT_NAME'] ?? '';

// Skip admin-ajax.php, admin-post.php, and wp-admin requests
if (strpos($request_uri, 'admin-ajax.php') !== false ||
    strpos($request_uri, 'admin-post.php') !== false ||
    strpos($request_uri, '/wp-admin/') !== false ||
    strpos($script_name, 'admin-ajax.php') !== false ||
    strpos($script_name, 'admin-post.php') !== false) {
    return; // Let WordPress handle these requests
}

// Skip wp-cron.php
if (strpos($request_uri, 'wp-cron.php') !== false ||
    strpos($script_name, 'wp-cron.php') !== false) {
    return;
}

// Skip wp-login.php (allow legitimate login attempts)
if (strpos($request_uri, 'wp-login.php') !== false ||
    strpos($script_name, 'wp-login.php') !== false) {
    return;
}

// 1. Load configuration first (to get trusted proxies)
$block_file = __DIR__ . '/upshield-blocked-ips.php';
$bin_file = __DIR__ . '/upshield-blocked-ips.bin';
$blocked_ips = [];
if (file_exists($block_file)) {
    $blocked_ips = include $block_file;
}

// 2. Get client IP securely
$ip = upshield_get_ip($blocked_ips['trusted_proxies'] ?? []);

// 3. Validate IP
if (!filter_var($ip, FILTER_VALIDATE_IP)) {
    return; // Invalid IP, let WordPress handle it
}

// 4. Check against block list
if (is_array($blocked_ips) && !empty($blocked_ips)) {
    // Check exact IP match (Legacy/Manual Blacklist from Config)
    if (isset($blocked_ips['exact'][$ip])) {
        $reason = $blocked_ips['exact'][$ip];
        // Determine attack type from reason
        $attack_type = 'ip_blacklist';
        
        if ($reason === 'Threat Intelligence') {
            $attack_type = 'threat_intelligence';
        } elseif (strpos($reason, 'Auto Block') === 0) {
            $attack_type = 'temp_block';
        } elseif ($reason === 'Blacklisted' || $reason === 'Manual Blacklist') {
            $attack_type = 'ip_blacklist';
        }
        
        upshield_block_request($ip, $reason, $attack_type);
    }
    
    // Check Binary File (High Performance Threat Intelligence)
    if (file_exists($bin_file)) {
        if (upshield_check_ip_binary($ip, $bin_file)) {
            upshield_block_request($ip, 'Threat Intelligence', 'threat_intelligence');
        }
    }
    
    // Check CIDR ranges
    if (!empty($blocked_ips['ranges'])) {
        foreach ($blocked_ips['ranges'] as $range => $reason) {
            if (upshield_ip_in_range($ip, $range)) {
                $attack_type = ($reason === 'Threat Intelligence') ? 'threat_intelligence' : '';
                upshield_block_request($ip, $reason, $attack_type);
            }
        }
    }
}

/**
 * Get client IP securely
 * 
 * @param array $trusted_proxies List of trusted proxy IPs/CIDRs
 * @return string Client IP
 */
function upshield_get_ip($trusted_proxies = []) {
    $remote_addr = $_SERVER['REMOTE_ADDR'] ?? '';
    
    // If no trusted proxies configured, fallback to REMOTE_ADDR (secure default)
    // or very basic Cloudflare check if we want to be nice to non-configured setups
    // But secure default is usually best.
    
    // Check if REMOTE_ADDR is a trusted proxy
    $is_trusted = false;
    
    // Always trust localhost/private loopback for testing
    if ($remote_addr === '127.0.0.1' || $remote_addr === '::1') {
        $is_trusted = true;
    }
    
    // Check against configured trusted proxies
    if (!$is_trusted && !empty($trusted_proxies)) {
        foreach ($trusted_proxies as $proxy) {
            if (upshield_ip_in_range($remote_addr, $proxy)) {
                $is_trusted = true;
                break;
            }
        }
    }
    
    // If not trusted, return REMOTE_ADDR
    if (!$is_trusted) {
        return $remote_addr;
    }
    
    // If trusted, check headers in order
    // 1. Cloudflare
    if (!empty($_SERVER['HTTP_CF_CONNECTING_IP'])) {
        // Extra security: Only trust CF header if REMOTE_ADDR is actually Cloudflare
        // For now, we assume if user added proxy to trusted list, they trust it.
        return $_SERVER['HTTP_CF_CONNECTING_IP'];
    }
    
    // 2. X-Real-IP (Nginx)
    if (!empty($_SERVER['HTTP_X_REAL_IP'])) {
        return $_SERVER['HTTP_X_REAL_IP'];
    }
    
    // 3. X-Forwarded-For
    if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
        $ips = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);
        $ip = trim($ips[0]);
        if (filter_var($ip, FILTER_VALIDATE_IP)) {
            return $ip;
        }
    }
    
    return $remote_addr;
}

/**
 * Block request immediately
 */
function upshield_block_request($ip, $reason = 'Blocked by UpShield WAF', $attack_type = '') {
    // Log to database and get Block ID (reused if recently blocked)
    $block_id = upshield_log_to_database($ip, $reason, $attack_type);
    
    // Fallback if logging failed or returned nothing
    if (empty($block_id)) {
        $block_id = substr(md5($ip . time()), 0, 12);
    }
    
    // Status code
    $status = 403;
    // Generic message for visitors, ignoring the internal reason
    $display_message = 'Sorry, you have been blocked for security reasons.';
    $accent_color = '#dc2626'; // Red for critical/high
    $current_time = gmdate('Y-m-d H:i:s');
    $timezone_label = 'UTC';
    
    // Send 403 response
    http_response_code(403);
    header('Content-Type: text/html; charset=UTF-8');
    
    // Beautiful block page inline
    echo '<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>' . htmlspecialchars($status) . ' - Request Blocked | UpShield WAF</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px; color: #e2e8f0; }
        .container { max-width: 600px; width: 100%; text-align: center; }
        .shield-icon { width: 120px; height: 120px; margin: 0 auto 30px; position: relative; }
        .shield-icon svg { width: 100%; height: 100%; filter: drop-shadow(0 0 30px ' . $accent_color . '40); }
        .status-code { font-size: 72px; font-weight: 800; color: ' . $accent_color . '; text-shadow: 0 0 40px ' . $accent_color . '60; margin-bottom: 10px; }
        .status-text { font-size: 24px; font-weight: 600; color: #f8fafc; margin-bottom: 30px; }
        .message-box { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-left: 4px solid ' . $accent_color . '; border-radius: 12px; padding: 25px; margin-bottom: 30px; backdrop-filter: blur(10px); }
        .message-box p { font-size: 16px; line-height: 1.6; color: #cbd5e1; }
        .info-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 30px; }
        .info-item { background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 8px; padding: 15px; }
        .info-item .label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #64748b; margin-bottom: 5px; }
        .info-item .value { font-size: 14px; font-family: "Monaco", "Consolas", monospace; color: #94a3b8; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .footer p { font-size: 13px; color: #475569; }
        .footer a { color: #64748b; text-decoration: none; transition: color 0.3s; }
        .footer a:hover { color: #94a3b8; }
        @media (max-width: 480px) { .status-code { font-size: 48px; } .status-text { font-size: 18px; } .info-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="shield-icon">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2L3 7V12C3 17.55 6.84 22.74 12 24C17.16 22.74 21 17.55 21 12V7L12 2Z" fill="' . $accent_color . '" fill-opacity="0.2" stroke="' . $accent_color . '" stroke-width="1.5"/>
                <path d="M12 8V12M12 16H12.01" stroke="' . $accent_color . '" stroke-width="2" stroke-linecap="round"/>
            </svg>
        </div>
        
        <div class="status-code">' . htmlspecialchars($status) . '</div>
        <div class="status-text">Access Denied</div>
        
        <div class="message-box">
            <p>' . htmlspecialchars($display_message) . '</p>
        </div>
        
        <div class="info-grid">
            <div class="info-item">
                <div class="label">Block ID</div>
                <div class="value">' . htmlspecialchars($block_id) . '</div>
            </div>
            <div class="info-item">
                <div class="label">Time (' . htmlspecialchars($timezone_label) . ')</div>
                <div class="value">' . htmlspecialchars($current_time) . '</div>
            </div>
        </div>
        
        <div class="footer">
            <p>Protected by <strong><a href="https://upshield.org" target="_blank" rel="noopener noreferrer">UpShield WAF</a></strong></p>
        </div>
    </div>
</body>
</html>';
    
    exit;
}

/**
 * Check IP against binary blocklist using Binary Search
 * 
 * @param string $ip Client IP
 * @param string $bin_file Path to binary file
 * @return bool True if blocked
 */
function upshield_check_ip_binary($ip, $bin_file) {
    if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
        return false; // Binary list only supports IPv4 for now
    }
    
    $ip_long = ip2long($ip);
    if ($ip_long === false) {
        return false;
    }
    
    $fp = @fopen($bin_file, 'rb');
    if (!$fp) {
        return false;
    }
    
    // Read count (first 4 bytes)
    $header = fread($fp, 4);
    if (strlen($header) < 4) {
        fclose($fp);
        return false;
    }
    
    $count = unpack('N', $header)[1];
    
    $low = 0;
    $high = $count - 1;
    
    while ($low <= $high) {
        $mid = floor(($low + $high) / 2);
        
        // Seek to position: 4 bytes headers + (mid * 4 bytes per IP)
        fseek($fp, 4 + ($mid * 4));
        
        $data = fread($fp, 4);
        if (strlen($data) < 4) {
            break;
        }
        
        $stored_ip = unpack('N', $data)[1];
        
        if ($stored_ip == $ip_long) {
            fclose($fp);
            return true; // Found
        }
        
        if ($stored_ip < $ip_long) {
            $low = $mid + 1;
        } else {
            $high = $mid - 1;
        }
    }
    
    fclose($fp);
    return false;
}

/**
 * Log threat intelligence block to database
 * This runs before WordPress loads, so we connect directly to database
 */
function upshield_log_to_database($ip, $reason, $attack_type, $block_id = null) {
    // Try to get database config from wp-config.php
    $wp_content_dir = __DIR__;
    $root_dir = dirname($wp_content_dir);
    
    // Standard location
    $wp_config_path = $root_dir . '/wp-config.php';
    
    // Fallback: Moved up one level (security best practice)
    if (!file_exists($wp_config_path)) {
        $wp_config_path = dirname($root_dir) . '/wp-config.php';
    }
    
    if (!file_exists($wp_config_path)) {
        // Log error for debugging
        error_log("UpShield Early Blocker: Could not locate wp-config.php at $wp_config_path");
        return; // Can't log without config
    }
    
    // Parse wp-config.php to get DB credentials
    $db_config = upshield_parse_wp_config($wp_config_path);
    if (empty($db_config)) {
        return; // Failed to parse config
    }
    
    // Connect to database
    try {
        // Parse DB_HOST (may contain port like localhost:3306)
        $db_host = $db_config['DB_HOST'];
        $db_port = 3306; // Default MySQL port
        
        if (strpos($db_host, ':') !== false) {
            list($db_host, $db_port) = explode(':', $db_host, 2);
            $db_port = (int) $db_port;
        }
        
        // Handle socket connection (localhost:/path/to/socket)
        if (strpos($db_config['DB_HOST'], ':') === 0) {
            $db_host = 'localhost';
            $db_socket = substr($db_config['DB_HOST'], 1);
            $mysqli = new mysqli($db_host, $db_config['DB_USER'], $db_config['DB_PASSWORD'], $db_config['DB_NAME'], null, $db_socket);
        } else {
            $mysqli = new mysqli($db_host, $db_config['DB_USER'], $db_config['DB_PASSWORD'], $db_config['DB_NAME'], $db_port);
        }
        
        if ($mysqli->connect_error) {
            return; // Connection failed, silently fail
        }
        
        // Get table prefix and validate (only alphanumeric and underscore)
        $table_prefix = $db_config['table_prefix'] ?? 'wp_';
        $table_prefix = preg_replace('/[^a-zA-Z0-9_]/', '', $table_prefix); // Sanitize
        $logs_table = $table_prefix . 'upshield_logs';
        
        // Escape table name (only alphanumeric, underscore allowed)
        $logs_table = preg_replace('/[^a-zA-Z0-9_]/', '', $logs_table);
        
        // Prepare request data
        $request_uri = $_SERVER['REQUEST_URI'] ?? '';
        $request_method = $_SERVER['REQUEST_METHOD'] ?? 'GET';
        $user_agent = $_SERVER['HTTP_USER_AGENT'] ?? '';
        $referer = $_SERVER['HTTP_REFERER'] ?? '';
        
        // Get country if available (try to get from request or use empty)
        $country = '';
        
        // Prepare SQL with escaped table name
        // Prepare SQL with escaped table name
        // Use PHP generated timestamp (UTC) for consistency across environments
        
        // Anti-Spam: Check if recently logged (deduplicate)
        // Only log if NO log exists for this IP and Attack Type in the last 1 HOUR
        // NOTE: We retrieve the EXISTING block_id to reuse it for the user display
        $check_sql = "SELECT block_id FROM {$logs_table} WHERE ip = ? AND attack_type = ? AND timestamp > DATE_SUB(?, INTERVAL 1 HOUR) ORDER BY id DESC LIMIT 1";
        $check_stmt = $mysqli->prepare($check_sql);
        
        $existing_block_id = null;
        
        if ($check_stmt) {
             $now_check = gmdate('Y-m-d H:i:s');
             $check_stmt->bind_param('sss', $ip, $attack_type, $now_check);
             $check_stmt->execute();
             $check_stmt->store_result();
             
             if ($check_stmt->num_rows > 0) {
                 $check_stmt->bind_result($existing_block_id);
                 $check_stmt->fetch();
             }
             $check_stmt->close();
        }
        
        // If we found an existing block log, Reuse the ID and Skip inserting
        if (!empty($existing_block_id)) {
            $mysqli->close();
            return $existing_block_id;
        }

        // If no existing log, generate NEW block_id if not provided
        if (empty($block_id)) {
            $block_id = substr(md5($ip . time()), 0, 12);
        }

        $sql = "INSERT INTO `{$logs_table}` 
            (ip, country, request_uri, request_method, user_agent, referer, post_data, 
             action, rule_id, rule_matched, attack_type, severity, block_id, timestamp) 
            VALUES (?, ?, ?, ?, ?, ?, ?, 'blocked', 'threat_intelligence', ?, ?, 'critical', ?, ?)";
        
        $stmt = $mysqli->prepare($sql);
        
        if ($stmt) {
            $rule_matched = $reason;
            $post_data = '';
            // Block ID is already ensured to be set above
            $timestamp = gmdate('Y-m-d H:i:s');
            
            $stmt->bind_param('sssssssssss',
                $ip,
                $country,
                $request_uri,
                $request_method,
                $user_agent,
                $referer,
                $post_data,
                $rule_matched,
                $attack_type,
                $block_id,
                $timestamp
            );
            
            $stmt->execute();
            $stmt->close();
            
            // --- SYNC TO THREATS SHARING QUEUE ---
            // Early blocks were previously not synced. Fixing this to ensure all blocks are shared.
            $queue_table = $table_prefix . 'upshield_threats_queue';
            $domain = $_SERVER['HTTP_HOST'] ?? '';
            $now = gmdate('Y-m-d H:i:s');
            
            // Check for existing pending queue item
            $q_check = "SELECT id FROM {$queue_table} WHERE ip = ? AND submitted = 0 LIMIT 1";
            $q_stmt = $mysqli->prepare($q_check);
            if ($q_stmt) {
                $q_stmt->bind_param('s', $ip);
                $q_stmt->execute();
                $q_stmt->store_result();
                
                if ($q_stmt->num_rows > 0) {
                    // Update existing
                    $q_stmt->bind_result($q_id);
                    $q_stmt->fetch();
                    $q_stmt->close();
                    
                    $q_upd = "UPDATE {$queue_table} SET reason = ?, attack_type = ?, updated_at = ? WHERE id = ?";
                    $u_stmt = $mysqli->prepare($q_upd);
                    if ($u_stmt) {
                        $u_stmt->bind_param('sssi', $reason, $attack_type, $now, $q_id);
                        $u_stmt->execute();
                        $u_stmt->close();
                    }
                } else {
                    $q_stmt->close();
                    // Insert new
                    $q_ins = "INSERT INTO {$queue_table} (ip, reason, attack_type, severity, domain, created_at, updated_at, submitted) VALUES (?, ?, ?, 'high', ?, ?, ?, 0)";
                    $i_stmt = $mysqli->prepare($q_ins);
                    if ($i_stmt) {
                        $i_stmt->bind_param('ssssss', $ip, $reason, $attack_type, $domain, $now, $now);
                        $i_stmt->execute();
                        $i_stmt->close();
                    }
                }
            }
            // -------------------------------------
        }
        
        $mysqli->close();
        
        return $block_id;
    } catch (Exception $e) {
        // Silently fail - but return generated ID if possible
        return $block_id ?? null;
    }
}

/**
 * Parse wp-config.php to extract database credentials
 */
function upshield_parse_wp_config($config_path) {
    if (!file_exists($config_path)) {
        return null;
    }
    
    $config_content = file_get_contents($config_path);
    $config = [];
    
    // Extract DB_NAME
    if (preg_match("/define\s*\(\s*['\"]DB_NAME['\"]\s*,\s*['\"](.+?)['\"]\s*\)/", $config_content, $matches)) {
        $config['DB_NAME'] = $matches[1];
    }
    
    // Extract DB_USER
    if (preg_match("/define\s*\(\s*['\"]DB_USER['\"]\s*,\s*['\"](.+?)['\"]\s*\)/", $config_content, $matches)) {
        $config['DB_USER'] = $matches[1];
    }
    
    // Extract DB_PASSWORD
    if (preg_match("/define\s*\(\s*['\"]DB_PASSWORD['\"]\s*,\s*['\"](.+?)['\"]\s*\)/", $config_content, $matches)) {
        $config['DB_PASSWORD'] = $matches[1];
    }
    
    // Extract DB_HOST
    if (preg_match("/define\s*\(\s*['\"]DB_HOST['\"]\s*,\s*['\"](.+?)['\"]\s*\)/", $config_content, $matches)) {
        $config['DB_HOST'] = $matches[1];
    }
    
    // Extract table_prefix
    if (preg_match("/\\\$table_prefix\s*=\s*['\"](.+?)['\"]/", $config_content, $matches)) {
        $config['table_prefix'] = $matches[1];
    }
    
    // Validate we have all required fields
    if (empty($config['DB_NAME']) || empty($config['DB_USER']) || empty($config['DB_HOST'])) {
        return null;
    }
    
    return $config;
}

/**
 * Check if IP is in CIDR range
 */
function upshield_ip_in_range($ip, $range) {
    if (strpos($range, '/') === false) {
        return $ip === $range;
    }
    
    list($subnet, $bits) = explode('/', $range);
    
    // IPv4
    if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
        $ip_long = ip2long($ip);
        $subnet_long = ip2long($subnet);
        $mask = -1 << (32 - (int) $bits);
        $subnet_long &= $mask;
        return ($ip_long & $mask) === $subnet_long;
    }
    
    // IPv6 (simplified check)
    if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
        // For IPv6, we'll do a simple prefix match
        $ip_hex = bin2hex(inet_pton($ip));
        $subnet_hex = bin2hex(inet_pton($subnet));
        $prefix_len = (int) ($bits / 4); // Each hex char is 4 bits
        return substr($ip_hex, 0, $prefix_len) === substr($subnet_hex, 0, $prefix_len);
    }
    
    return false;
}
